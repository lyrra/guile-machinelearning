(define-module (guile-machinelearning examples lstm)
  #:use-module (ice-9 match)
  #:use-module (ice-9 format)
  #:use-module (guile-machinelearning arr)
  #:use-module (guile-machinelearning mat)
  #:use-module (guile-machinelearning activations)
  #:export (lstm-cell-forward lstm-forward
            lstm-cell-backward lstm-backward))

; see examples/rnn.scm for variable naming and dimensions of arrays

(define (new-arr dim)
  (let ((arr (apply make-array #f dim)))
    (array-fill! arr 0)
    arr))

(define (lstm-cell-forward xt a_prev c_prev Wf bf Wi bi Wo bo Wc bc Wy by)
  (match (list (array-dimensions xt)
               (array-dimensions Wy))
    (((n_x m) (n_y n_a))
     (let* ((concat (arr-concat-rows (list a_prev xt)))
            (ft (arr-sigmoid (arr-+ (arr-dot Wf concat) bf)))
            (it (arr-sigmoid (arr-+ (arr-dot Wi concat) bi)))
            (ot (arr-sigmoid (arr-+ (arr-dot Wo concat) bo)))
            (cct (arr-tanh (arr-+ (arr-dot Wc concat) bc)))
            (c_next (arr-+ (arr-* c_prev ft) (arr-* cct it)))
            (a_next (arr-* ot (arr-tanh c_next)))
            (yt_pred (if Wy (softmax (arr-+ (arr-dot Wy a_next) by)) #f)))
       (list a_next c_next yt_pred
             (list a_next c_next a_prev c_prev ft it cct ot xt))))))

(define (lstm-forward x a0 Wf bf Wi bi Wo bo Wc bc Wy by)
  (match (list (array-dimensions x)
               (if Wy (array-dimensions Wy) (list #f #f)))
    (((n_x m T_x) (n_y n_a))
     (let (; Create a 3D shape (n_a, m, T_x) of zeros, that holds the hidden state.
           (a (arr-zero! (new-arr (list n_a m T_x))))
           (c (arr-zero! (new-arr (list n_a m T_x))))
           (y (arr-zero! (new-arr (list n_y m T_x))))
           ; Create a 3d shape (n_y, m, T_x) that holds predictions.
           (a_prev a0)
           (c_prev (arr-zero! (new-arr (list n_a m))))
           (caches '()))
       (do ((t 0 (1+ t)))
           ((>= t T_x))
         (match (lstm-cell-forward (arr-slice x `(* * ,t))
                                   a_prev c_prev
                                   Wf bf Wi bi Wo bo Wc bc Wy by)
           ((a_next c_next yt cache)
            (arr-insert a a_next `(* * ,t))
            (arr-insert c c_next `(* * ,t))
            (arr-insert y yt     `(* * ,t))
            (set! caches (cons cache caches))
            (set! a_prev a_next)
            (set! c_prev c_next))))
       (list a y c (list (reverse caches) x))))))

(define (lstm-cell-backward da_next dc_next cache Wf bf Wi bi Wo bo Wc bc Wy by)
  (match cache
    ((a_next c_next a_prev c_prev ft it cct ot xt)
     (match (list (array-dimensions xt)
                  (array-dimensions a_next))
       (((n_x m) (n_a m))
        (let* ((dot (arr-* da_next (arr-proc tanh c_next) ot
                           (arr-proc (lambda (o) (- 1 o)) ot)
                           ;(arr-- 1 ot)
                           ))
               (tanh2cnext (arr-proc (lambda (c) (expt (tanh c) 2)) c_next))
               (1-tanh2cnext (arr-proc (lambda (x) (- 1 x)) tanh2cnext))
               (dcct (arr-* (arr-+ (arr-* dc_next it)
                                   (arr-* ot 1-tanh2cnext it da_next))
                            (arr-proc (lambda (c) (- 1 (expt c 2))) cct)))
               (dit (arr-* (arr-+ (arr-* dc_next cct)
                                  (arr-* ot 1-tanh2cnext cct da_next))
                           it (arr-proc (lambda (i) (- 1 i)) it)))
               (dft (arr-* (arr-+ (arr-* dc_next c_prev)
                                  (arr-* ot 1-tanh2cnext c_prev da_next))
                           ft (arr-proc (lambda (i) (- 1 i)) ft)))
               (apxt (arr-tr (arr-concat-rows (list a_prev xt))))
               (dWf (arr-dot dft apxt))
               (dWi (arr-dot dit apxt))
               (dWc (arr-dot dcct apxt))
               (dWo (arr-dot dot apxt))
               (dbf (new-arr `(,n_a 1)))
               (dbi (new-arr `(,n_a 1)))
               (dbc (new-arr `(,n_a 1)))
               (dbo (new-arr `(,n_a 1)))
               (dc_prev (arr-+ (arr-* dc_next ft)
                               (arr-* ot 1-tanh2cnext ft da_next)))
               (da_prev (arr-+ (arr-dot (arr-tr (arr-select Wf `(* (< ,n_a)))) dft)
                               (arr-dot (arr-tr (arr-select Wi `(* (< ,n_a)))) dit)
                               (arr-dot (arr-tr (arr-select Wc `(* (< ,n_a)))) dcct)
                               (arr-dot (arr-tr (arr-select Wo `(* (< ,n_a)))) dot)))
               (dxt     (arr-+ (arr-dot (arr-tr (arr-select Wf `(* (>= ,n_a)))) dft)
                               (arr-dot (arr-tr (arr-select Wi `(* (>= ,n_a)))) dit)
                               (arr-dot (arr-tr (arr-select Wc `(* (>= ,n_a)))) dcct)
                               (arr-dot (arr-tr (arr-select Wo `(* (>= ,n_a)))) dot))))
          (arr-fold-cols! dbf dft)
          (arr-fold-cols! dbi dit)
          (arr-fold-cols! dbc dcct)
          (arr-fold-cols! dbo dot)
          (list dxt da_prev dc_prev dWf dbf dWi dbi dWc dbc dWo dbo)))))))

(define (lstm-backward Y yh caches Wf bf Wi bi Wo bo Wc bc Wy by)
  (let* ((caches-last (car caches))
         (x (cadr caches)))
    (match (car caches-last)
      ((a1 c1 a0 c0 f1 i1 cc1 o1 x1)
       (match (list (array-dimensions yh)
                    (array-dimensions Wf)
                    (array-dimensions x1))
         (((n_y m T_x) (n_a n_x+n_a) (n_x m2))
          (if (not (= m m2)) (error "m mismatch" m m2))
          (let ((dx       (new-arr (list n_x m T_x)))
                (da0      (new-arr (list n_a m)))
                (da_prevt (new-arr (list n_a m)))
                (dc_prevt (new-arr (list n_a m)))
                (dWy (new-arr (list n_y n_a)))
                (dWf (new-arr (list n_a (+ n_a n_x))))
                (dWi (new-arr (list n_a (+ n_a n_x))))
                (dWc (new-arr (list n_a (+ n_a n_x))))
                (dWo (new-arr (list n_a (+ n_a n_x))))
                (dby (new-arr (list n_y 1)))
                (dbf (new-arr (list n_a 1)))
                (dbi (new-arr (list n_a 1)))
                (dbc (new-arr (list n_a 1)))
                (dbo (new-arr (list n_a 1))))
            ; loop through all time steps, T_x: 4 n_a: 5 n_x: 3 m: 10
            (let ((d (make-arr n_a m)))
            (do ((t (1- T_x) (1- t))) ((< t 0))
              (array-fill! d 0)
              (do ((n 0 (1+ n))) ((>= n m))
                ; propagate through softmax
                ;dy = np.copy(y_hat[t])
                ;dy[Y[t]] -= 1
                (let ((dyt (new-arr (list n_y 1)))
                      (idx (inexact->exact (array-ref Y t n)))
                      (a_next (car (list-ref caches-last t))))
                  (do ((i 0 (1+ i))) ((>= i n_y))
                    (array-set! dyt (array-ref yh i 0 t) i 0))
                  (array-set! dyt (- (array-ref dyt idx 0) 1) idx 0)
                  ; dWya += np.dot(dy, a.T)
                  (arr-+! dWy (arr-dot dyt (arr-tr (arr-select a_next `(* ,n) #t))))
                  (arr-+! dby dyt)
                  (arr-insert d (arr-dot (arr-tr Wy) dyt) `(* ,n))))
              ; dat = np.dot(Wya.T, dy) + da_next # backprop into h
              (arr-+! d da_prevt)
              (match (lstm-cell-backward d dc_prevt (list-ref caches-last t #|(- T_x t 1) |#) Wf bf Wi bi Wo bo Wc bc Wy by)
                ((dxt_ da_prev_ dc_prev_ dWf_ dbf_ dWi_ dbi_ dWc_ dbc_ dWo_ dbo_)
                 (arr-insert dx dxt_ `(* * ,t))
                 (arr-+! dWf dWf_) (arr-+! dbf dbf_)
                 (arr-+! dWi dWi_) (arr-+! dbi dbi_)
                 (arr-+! dWc dWc_) (arr-+! dbc dbc_)
                 (arr-+! dWo dWo_) (arr-+! dbo dbo_)
                 (set! da_prevt da_prev_)
                 (set! dc_prevt dc_prev_)))))
            (set! da0 da_prevt)
            (list dx da0 dWf dbf dWi dbi dWc dbc dWo dbo dWy dby))))))))
